아래는 지금까지 정리한 내용을 **개발팀용 워크플로우 태스크 목록 + 프롬프트 템플릿**으로 재구성한 것입니다.  
각 메이저 태스크는 실제 작업 단위(티켓/스토리)로, 서브 태스크는 그 안에서 체크리스트로 보시면 됩니다.

***

## 🟥 메이저 태스크 1. 게임 상태 보안 하드닝 (Anti‑Cheat & Validation)

### 🎯 목표
- 브라우저 콘솔에서 `useGameStore`를 직접 조작해도 치트가 불가능하게 만들기
- 세이브/로드 데이터에 대해 스키마 기반 검증을 적용해, 손상되거나 조작된 데이터를 막기

***

### ✅ Task 1-1. 상태 변조 방지 (Zustand 스토어 보호)

**프롬프트 형식**

> 당신은 Retro Stock OS 프로젝트의 **게임 상태 보안 담당 프론트엔드 개발자**입니다.  
> 현재 게임 상태는 Zustand 단일 스토어로 관리되고 있으며, 브라우저 콘솔에서 `getState()` / `setState()`를 통해 직접 조작이 가능합니다.  
> 이로 인해 플레이어가 현금, 포트폴리오 등을 마음대로 바꿀 수 있는 치트 취약점이 존재합니다.
>
> 아래 요구사항에 따라 **스토어 내부 검증 계층과 외부 접근 감지 로직을 추가**하는 작업을 수행하세요.
>
> #### 요구사항
> - `src/stores/gameStore.ts` 내 게임 스토어에 다음을 적용:
    >   - 내부에서만 사용하는 `validatedSet` 또는 유사한 래퍼를 만들어,
          >     - `cash`가 0 이상인지
>     - 보유 주식 수가 0 이상인지
>     - 그 외 핵심 필드가 비정상 값(예: NaN, Infinity, 음수)인지  
        >     를 체크 후, 이상 값이 발견되면 에러 또는 경고를 발생시킬 것.
>   - 스토어 외부에서 무분별하게 `setState`로 전체 상태를 덮어쓰는 경로를 제거하거나 최소화할 것.
> - 개발/테스트 목적으로 상태를 읽어야 하는 경우와, 실제 게임 로직에서 내부적으로 상태를 갱신하는 경우를 분리:
    >   - 내부 로직: 검증 계층을 반드시 지나도록 구조화
>   - 콘솔에서 임의로 `setState` 하는 행위는 경고 또는 차단
> - 프로덕션 빌드에서는 `window` 객체에 직접 스토어를 노출하지 않거나, 노출되더라도 쓰기/수정이 차단되도록 할 것.
>
> #### 세부 작업
> - [ ] `gameStore`에서 상태를 갱신하는 모든 public 메서드 목록화 (예: `buyStock`, `sellStock`, `hireEmployee` 등)
> - [ ] 각 메서드가 내부 검증 함수를 통해서만 상태를 변경하도록 리팩토링
> - [ ] 개발 환경과 프로덕션 환경에서 `window`에 노출되는 전역 객체를 점검하고, 프로덕션에서는 쓰기 방지
> - [ ] 비정상 상태 감지 시 콘솔에 경고를 남기고, 추후 로깅 시스템과 연동할 수 있도록 훅 포인트 남기기
>
> #### 완료 조건
> - 콘솔에서 `useGameStore.getState().player.cash = 999999999`처럼 직접 수정해도 실제 게임 UI/로직에서 반영되지 않거나, 즉시 되돌려지는 것 확인
> - 잘못된 상태 갱신 시(음수 cash, 음수 shares 등) 에러 또는 경고가 출력되는 것 확인
> - 기존 정상 플레이 플로우(매수/매도, 세이브/로드)가 깨지지 않는 것 확인
>
> #### 참고
> - 보안/결함 분석: `comprehensive-review.md`의 “2.1 상태 변조 취약점” 섹션
> - 전체 상태 구조/타입: `src/types/index.ts`, `src/stores/gameStore.ts`

***

### ✅ Task 1-2. 세이브/로드 입력 검증 (스키마 기반 Validation)

**프롬프트 형식**

> 당신은 Retro Stock OS의 **세이브/로드 시스템 담당 개발자**입니다.  
> 현재 IndexedDB(Dexie)를 통해 세이브 데이터를 읽고 쓰지만, 로드 시 데이터 구조/값 검증이 충분하지 않습니다.  
> 손상된 데이터 또는 수동 조작된 JSON이 로드되면 게임이 비정상 상태가 될 수 있습니다.
>
> 아래 요구사항에 따라 **스키마 기반 검증(Zod 또는 유사 라이브러리)**을 적용해 입력을 강하게 검증하세요.
>
> #### 요구사항
> - `src/systems/saveSystem.ts` 또는 대응 위치에 다음을 적용:
    >   - 세이브 데이터 전체를 표현하는 `GameState` 스키마 정의 파일 생성 (예: `src/schemas/gameStateSchema.ts`)
>   - 핵심 필드 제약:
      >     - `player.cash`, `player.netWorth`: 0 이상, 상한값(예: 1e10, 1e11 등) 지정
>     - `player.employees` 개수 상한 지정 (예: 최대 200명)
>     - `companies` 배열 길이 고정 (예: 정확히 100개)
>     - `priceHistory` 길이 상한 (예: 300개)
>   - 로드 시:
      >     - IndexedDB에서 읽은 raw 데이터를 스키마로 `safeParse`
>     - 실패 시: 에러 로깅 + 로드 실패 처리 (필요하면 백업 슬롯 시도)
>   - 세이브 시:
      >     - 현재 메모리의 게임 상태를 스키마로 검증 후, 검증 통과한 상태만 저장
> - 스키마 기반 검증으로 인해 기존 세이브 파일과의 호환성이 깨지지 않도록 마이그레이션 전략 준비 (버전 필드 등).
>
> #### 세부 작업
> - [ ] 스키마 정의 파일 생성 (`GameState`/`Player`/`Company` 등)
> - [ ] `loadGame` 경로에 스키마 검증 추가
> - [ ] `saveGame` 경로에 스키마 검증 추가
> - [ ] 잘못된 데이터(예: 음수 cash) 세이브/로드 테스트 케이스 추가
>
> #### 완료 조건
> - 손상된 JSON 또는 비정상 값이 포함된 세이브를 로드할 때 게임이 크래시하지 않고, “로드 실패” 시나리오로 안전하게 빠지는 것 확인
> - 정상 세이브/로드 플로우가 기존과 동일하게 작동하는 것 확인
>
> #### 참고
> - 위험 분석: `comprehensive-review.md`의 “2.3 입력 검증 부족”
> - 갭 분석: `gap-analysis-summary.md`의 Sprint 5 항목(세이브 호환성)

***

## 🟧 메이저 태스크 2. 성능 최적화 (Tick & 계산 비용 절감)

### 🎯 목표
- 포트폴리오 가치 계산, 직원 AI, 렌더링 등 반복 연산의 비용을 줄여 60FPS에 최대한 근접하게 유지

***

### ✅ Task 2-1. 포트폴리오 가치 계산 Incremental Update

**프롬프트 형식**

> 당신은 Retro Stock OS의 **퍼포먼스 최적화 담당 개발자**입니다.  
> 현재 포트폴리오 가치 계산이 `포트폴리오 × 상장사 수` 만큼 매 틱마다 반복되어 O(10,000) 수준의 연산이 발생합니다.  
> 이를 **가격이 실제로 변한 종목만 반영하는 Incremental Update 방식**으로 최적화해야 합니다.
>
> #### 요구사항
> - `src/engines/tickEngine.ts` 또는 포트폴리오 가치 계산 위치에서:
    >   - 매 틱마다 전체 포트폴리오 × 전체 회사 루프를 도는 구조를 제거
>   - “이전 틱 가격 스냅샷”과 “이번 틱 업데이트된 가격”을 비교해, 변동이 있는 종목만 골라냄
>   - 변동이 있는 종목에 대해서만 보유 수량 × 가격 변화분을 계산해, 누적 포트폴리오 가치에 더하는 방식으로 전환
> - 최종적으로:
    >   - 평균 틱 처리 시간이 기존 대비 **두 자릿수 이상(예: 10배 이상)** 개선되었는지 성능 측정
>
> #### 세부 작업
> - [ ] 현재 포트폴리오 가치 계산 로직 위치 파악 및 비용 분석
> - [ ] “이전 가격”과 “현재 가격”을 비교할 수 있는 구조(맵, 스냅샷 등) 설계
> - [ ] Incremental Update 방식으로 로직 교체
> - [ ] 1,000틱 이상 시뮬레이션을 돌리는 성능 테스트 작성 및 Before/After 측정
>
> #### 완료 조건
> - 1,000틱 시뮬레이션 기준, 포트폴리오 가치 계산에 소요되는 평균 시간이 1ms 이하로 줄어든 것 확인
> - 실제 게임 플레이에서 FPS 저하 현상이 눈에 띄게 감소
>
> #### 참고
> - 성능 분석: `comprehensive-review.md`의 “2.2 포트폴리오 값 계산 성능” 및 “5. 성능 최적화”

***

### ✅ Task 2-2. 직원 AI 업데이트 분산/샘플링 (선택)

**프롬프트 형식**

> 당신은 직원 AI 성능 최적화 담당입니다.  
> 직원 수가 많아질수록(예: 100명 이상) 매 틱마다 전 직원의 AI를 평가하면 연산량이 급증합니다.  
> 이를 **틱 분산(샤딩)** 방식으로 최적화해 전체 연산량을 분산해야 합니다.
>
> #### 요구사항
> - `src/engines/employeeBehavior.ts` 및 `src/engines/officeSystem.ts`에서:
    >   - 전 직원에 대해 매 틱마다 AI를 돌리지 않고, N틱 단위로 분산 처리
>   - 예시: `employeeIndex % interval === tick % interval` 같은 방식으로 일부만 처리
> - 시뮬레이션 결과가 지나치게 느려지지 않도록, 체감 반응성(스트레스 변화, 상호작용 발생 등)은 유지
>
> #### 세부 작업
> - [ ] 현재 직원 AI 호출 빈도와 비용 측정
> - [ ] 적절한 interval 값(예: 5틱, 10틱) 실험
> - [ ] 분산 처리 전략 적용 및 밸런스 검증
>
> #### 완료 조건
> - 직원 100명 수준에서 장시간 플레이해도 CPU 사용량과 FPS가 안정적으로 유지
> - 직원 행동이 “멀쩡히 살고 있다”는 느낌을 유지 (반응성 저하가 체감되지 않을 것)

***

## 🟨 메이저 태스크 3. Office Overhaul Phase A (핵심 UX 완성)

### 🎯 목표
- 직원 정보를 “눈에 보이고, 클릭해서 깊게 볼 수 있고, 바로 피드백이 오는” UX로 완성

***

### ✅ Task 3-1. EmployeeDetail 모달 구현

**프롬프트 형식**

> 당신은 Retro Stock OS의 **Office UI 담당 프론트엔드 개발자**입니다.  
> 현재 사무실 화면(OfficeWindow)에서 직원 이모지를 클릭해도 상세 정보를 볼 수 없습니다.  
> `EmployeeDetail` 모달을 구현하여, 관리 시뮬레이션의 핵심 UX를 완성해야 합니다.
>
> #### 요구사항
> - 파일 위치: `src/components/office/EmployeeDetail.tsx` (신규)
> - 동작:
    >   - OfficeWindow의 그리드/리스트에서 직원 클릭 시 모달 팝업 표시
>   - 모달에는 다음 정보 표시:
      >     - 이름, 이모지, 역할/직급, 연봉, 고용일
>     - 스트레스, 만족도, 스태미너 (바 형태)
>     - 스킬(분석/거래/리서치 등)과 레벨
>     - 성격 태그(배지 형태)
>     - 최근 활동 로그(스크롤 가능)
>   - 닫기:
      >     - X 버튼, ESC 키, 배경 클릭 등으로 닫기 가능
> - 레트로 Windows 95 스타일을 유지하는 디자인 (기존 창 스타일 참고)
>
> #### 세부 작업
> - [ ] Employee 타입 정의 확인 (`src/types/index.ts`)
> - [ ] EmployeeDetail 컴포넌트 기본 레이아웃 작성
> - [ ] OfficeWindow 내에서 `selectedEmployee` 상태를 추가하고, 클릭 시 모달 연결
> - [ ] 키보드/마우스 이벤트로 모달 닫기 처리
>
> #### 완료 조건
> - 사무실 화면에서 아무 직원 이모지를 클릭하면, 상세 모달이 뜨고 모든 정보가 제대로 표시
> - ESC/배경 클릭 등으로 모달이 자연스럽게 닫힘
>
> #### 참고
> - 갭 분석: `gap-analysis-summary.md`의 Sprint 4 - “직원 상세 팝업” 항목
> - 전체 오피스 UX 의도: `implementation-roadmap.md`의 Week 1/Phase A 설명

***

### ✅ Task 3-2. OfficeToast: 실시간 알림 토스트 구현

**프롬프트 형식**

> 당신은 Retro Stock OS의 **알림/피드백 UI 담당 개발자**입니다.  
> 현재 직원 간 상호작용, 해고/채용, 사고 등 중요한 이벤트가 발생해도 플레이어가 바로 인지하기 어렵습니다.  
> 우하단에 잠깐 나타나는 **OfficeToast** 알림을 구현해 실시간 피드백을 제공합니다.
>
> #### 요구사항
> - 파일 위치: `src/components/office/OfficeToast.tsx` (신규)
> - 동작:
    >   - 화면 우하단에 최대 3개의 토스트가 쌓여 표시
>   - 각 토스트는 약 3초 뒤 자동으로 사라짐
>   - 유형별 스타일:
      >     - success: 좋은 일(승진, 프로젝트 성공 등)
>     - warning: 나쁜 징조(스트레스 증가, 갈등 등)
>     - info: 일반 알림
> - 데이터 소스:
    >   - store 내 `officeToasts` 배열(또는 유사 필드)을 사용
>   - `officeSystem`/`employeeInteraction`에서 특정 이벤트 발생 시 토스트 추가
>
> #### 세부 작업
> - [ ] Toast 타입 설계 (id, message, type, timestamp 등)
> - [ ] Zustand store에 `officeToasts`, 추가/삭제 액션 추가
> - [ ] OfficeToast 컴포넌트 작성 및 전체 앱 레이아웃에 포함
> - [ ] 대표적인 이벤트(채용, 해고, 심각한 스트레스 등)에 토스트 트리거 추가
>
> #### 완료 조건
> - 직원 해고/채용/갈등 등 주요 이벤트 발생 시, 우하단에 관련 메시지가 1~3초 내 표시
> - 동시에 여러 이벤트가 발생해도 최대 3개까지만 쌓이며 오래된 토스트가 자연스럽게 사라짐
>
> #### 참고
> - 갭 분석: `gap-analysis-summary.md` Sprint 4 - “알림 토스트 미구현”
> - 이벤트 소스: `src/engines/officeSystem.ts`, `src/engines/employeeInteraction.ts`, `src/data/chatter.ts`

***

## 🟩 메이저 태스크 4. Office Overhaul Phase B (시뮬레이션 품질 향상)

### 🎯 목표
- 뉴스/이벤트가 모든 회사를 똑같이 흔드는 단조로운 모델에서, “회사별 반응 차이 + 여진”이 있는 리얼리틱 모델로 업그레이드

***

### ✅ Task 4-1. 회사별 eventSensitivity 속성 추가

**프롬프트 형식**

> 당신은 Retro Stock OS의 **시장 시뮬레이션 밸런스 담당 개발자**입니다.  
> 현재 이벤트(뉴스)가 발생하면 동일한 로직으로 모든 회사/섹터에 거의 같은 비율로 적용되고 있습니다.  
> 각 회사별로 이벤트에 대한 민감도를 설정해, 리얼리즘과 전략성을 높여야 합니다.
>
> #### 요구사항
> - 파일 위치: `src/data/companies.ts`
> - 각 Company에 `eventSensitivity` 또는 유사 이름의 속성을 추가:
    >   - 키: 이벤트 카테고리(예: `"tech"`, `"policy"`, `"crash"` 등)
>   - 값: 반응 계수(0.0 ~ 2.0 정도; 1.0 = 기본 반응, 2.0 = 2배 민감)
> - `tickEngine`에서 이벤트 효과 적용 시, 회사별 `eventSensitivity`를 곱해 drift/volatility 변경
>
> #### 세부 작업
> - [ ] 현재 이벤트 타입/카테고리 정의 위치 확인 (`events.ts`, `newsEngine.ts` 등)
> - [ ] 주요 섹터별/회차별로 적절한 기본 민감도 테이블 설계
> - [ ] 회사를 순회하며 eventSensitivity 속성 데이터 채워넣기
> - [ ] 적용 전/후 시뮬레이션을 비교해, 특정 회사가 과도하게 튀지 않도록 밸런스 조정
>
> #### 완료 조건
> - 동일한 이벤트가 발생해도, tech 종목과 유틸리티 종목이 서로 다른 크기로 움직이는 것이 차트에서 확인 가능
> - 극단적인 값(cash crash 등)을 넣지 않는 한, 게임이 너무 불안정하게 되지 않을 것
>
> #### 참고
> - 갭 분석: `gap-analysis-summary.md` Sprint 2 - “회사별 감응도 미구현”
> - 이벤트/섹터 구조: `src/data/events.ts`, `src/data/sectorCorrelation.ts`

***

### ✅ Task 4-2. afterEffect(여진) 시스템 구현

**프롬프트 형식**

> 당신은 Retro Stock OS의 **이벤트 후속 효과(여진) 담당 개발자**입니다.  
> 현재 이벤트는 “발생 → 일정 틱 동안 영향 → 종료”로 깔끔하게 끝납니다.  
> 현실에 가깝게, 이벤트 종료 후에도 일정 기간 **잔여 효과(여진)**가 남도록 구현해야 합니다.
>
> #### 요구사항
> - 스토어/엔진에 `afterEffects` 또는 유사한 컬렉션을 추가하여,
    >   - 어떤 이벤트가
>   - 어떤 회사들에
>   - 얼마나 남은 틱 동안
>   - 어느 정도 residual drift/volatility를 남기는지  
      >   를 추적
> - 이벤트가 끝날 때:
    >   - 해당 이벤트를 기반으로 afterEffect 엔트리 생성 (예: 50틱, 원래 효과의 10% 정도)
> - 매 틱:
    >   - 남아 있는 afterEffect들에 따라 영향을 서서히 줄여나가는(선형 감쇠) 방식으로 가격에 반영
>
> #### 세부 작업
> - [ ] afterEffect를 표현하는 타입/인터페이스 정의
> - [ ] 이벤트 라이프사이클(시작~종료) 코드 위치 파악 (`tickEngine`, `newsEngine`, `events` 관련)
> - [ ] 이벤트 종료 시 afterEffect 엔트리 생성 로직 추가
> - [ ] 매 틱마다 afterEffect를 적용하고, 남은 틱이 0이 되면 제거하는 루프 구현
> - [ ] 테스트: 강한 이벤트(예: 금융위기)가 끝난 뒤에도 약하게 남아 있는지, 차트로 시각적으로 확인
>
> #### 완료 조건
> - 이벤트 종료 직후 가격이 즉시 정상 상태로 되돌아가지 않고, 일정 기간 서서히 안정을 찾아가는 모양새가 차트에서 확인
> - afterEffect 기능을 끄면(플래그 등), 기존 동작과 동일하게 작동
>
> #### 참고
> - 갭 분석: `gap-analysis-summary.md` Sprint 2 - “가격 전파 지연/여진 시스템”
> - 구현 로드맵: `implementation-roadmap.md` Week 2 설명

***

## 🟦 메이저 태스크 5. ChartWindow 시각화 강화 (선택, Phase C)

### 🎯 목표
- 차트에서 이벤트/센티먼트/여진을 한눈에 보이도록 정보 밀도와 가독성 향상

**프롬프트 개요 (요약)**

> - ChartWindow에 다음 요소를 추가:
    >   - 이벤트 기간을 나타내는 반투명 밴드(색상: severity에 따라)
>   - 하단 또는 별도 축에 센티먼트 지표 라인
>   - afterEffect 기간을 점선 등으로 표기
> - 상세 요구사항/순서는 `gap-analysis-summary.md`와 `implementation-roadmap.md`의 Phase C 참조

(해당 부분은 선택/후순위이므로 여기서는 개략만 두고, 실제 세부 프롬프트는 필요 시 따로 확장하는 것이 좋습니다.)

***

## 🟫 메이저 태스크 6. 구조/품질 리팩토링 (상수화, 스토어 분리 등)

### 🎯 목표
- 매직 넘버 제거, 게임 규칙 상수화를 통해 유지보수성/테스트 용이성 향상
- 비즈니스 로직과 UI 상태를 분리하여 스토어 단일 책임 원칙 강화

**프롬프트 개요**

> - `src/constants/gameRules.ts`(또는 유사 파일) 생성:
    >   - TICKS_PER_SECOND, MAX_PRICE_HISTORY, MAX_NEWS_ITEMS, STRESS_WARNING_THRESHOLD 등 모든 매직 넘버 이동
> - UI 관련 상태(`windows`, `zIndex`, 모달 열림 상태 등)를 별도 UI 스토어로 분리:
    >   - 게임 스토어는 순수한 도메인 상태(플레이어, 회사, 시간, 이벤트 등)만 유지
> - 세부 목록과 예시는 `comprehensive-review.md`의 “4. 코드 품질 이슈” 섹션 참고

***

## 🟪 메이저 태스크 7. 테스트 & QA (통합/성능/E2E)

### 🎯 목표
- 30분 이상 연속 플레이, 직원 100명 시나리오, 세이브/로드 반복 등에 대한 통합 테스트 확보

**프롬프트 개요**

> - 30분 플레이 시뮬레이션(가속 틱 기반) 통합 테스트 작성
> - 직원 100명, 이벤트 다수, 세이브/로드 반복 등의 스트레스 테스트 추가
> - E2E 레벨에서 기본 흐름(시작 → 몇 년 플레이 → 종료) 확인하는 시나리오 작성
> - 구체적인 테스트 아이디어는 `comprehensive-review.md` “6. 테스트 커버리지” 섹션 참고

***

## 📊 성능 최적화 분석 결과 (메이저 태스크 2 구현 완료)

### 분석된 병목

| 위치 | 문제 | 복잡도 |
|------|------|--------|
| `calcPortfolioValue()` (gameStore.ts:4004-4014) | `companies.find()` 선형 탐색 × 매 틱 | O(portfolio × companies) |
| `updatePrices()` 이벤트 스냅샷 (gameStore.ts:1486-1510) | `newCompanies.find()` × 매 이벤트 × 매 회사 | O(events × affectedCompanies × companies) |
| `updateCompetitorAssets()` (gameStore.ts:2868-2895) | `state.companies.find()` × 매 경쟁자 포지션 | O(competitors × positions × companies) |

### 적용한 최적화

1. **`buildPriceMap()` 헬퍼 도입**: `Company[]` → `Map<string, number>` 변환, O(n) 한 번 빌드
2. **`calcPortfolioValue()` 오버로드**: `Company[] | Map<string, number>` 인자 → 핫패스에서 Map 전달, 기존 호출 호환
3. **`updatePrices()` 내부**: priceMap 한 번 빌드 후 이벤트 스냅샷 + 포트폴리오 계산에 재사용
4. **`updateCompetitorAssets()`**: 함수 시작 시 priceMap 빌드 후 O(1) 조회로 전환

### 최적화 효과

- **매 틱 `updatePrices()`**: `find()` 3회 영역 → Map O(1) 조회로 전환 (20개 회사 기준 ~20배 탐색 감소)
- **경쟁자 자산 업데이트**: 4 경쟁자 × 다수 포지션의 `find()` 제거 → O(1) 조회
- 기존 코드의 기능적 동작은 100% 유지 (오버로드 방식으로 호환)

### 기존 구현 완료 상태

- **Task 2-2 (직원 AI 분산)**: 이미 구현됨 — `tickEngine.ts:347`에서 직원 수에 따라 분산 (≤5명: 10시간, ≤15명: 20시간, >15명: 30시간)
- **Task 3 (Office UX Phase A)**: EmployeeDetail 모달, OfficeToast 등 이미 구현 완료

***

## 마지막 정리

- 위 태스크들은 **순서대로** 진행하면 좋습니다:
    1. 메이저 1 (보안) → 2 (성능) → 3 (Office UX A)
    2. 그 다음 4 (시뮬레이션 강화) → 5 (시각화) → 6,7 (리팩토링/QA)
- 각 Task는 그대로 티켓 제목 + 설명에 붙여넣을 수 있는 **프롬프트 형식**으로 작성했습니다.
- 특정 태스크를 먼저 진행하고 싶다면, 그 태스크 블록만 복사해서 팀/툴(Jira, Notion, GitHub Issues, AI 에이전트 등)에 붙여넣으면 바로 사용할 수 있습니다.
